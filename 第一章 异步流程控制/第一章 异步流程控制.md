## 发布订阅模式

- 先订阅 再发布
- 需要把订阅的内容保存到订阅里，发布时让数组中的函数依次执行

```js
const fs = require("fs");

const school = {};

const Dep = {
  arr: [],
  on(fn) {
    this.arr.push(fn);
  },
  emit() {
    if (Object.keys(school).length === 3) {
      this.arr.forEach(function (item) {
        item();
      });
    }
  },
};

Dep.on(function () {
  console.log(school);
});

Dep.on(function () {
  console.log("读取结束了");
});

fs.readFile("./address.txt", "utf8", function (err, res) {
  school.address = res;
  Dep.emit();
});

fs.readFile("./age.txt", "utf8", function (err, res) {
  school.age = res;
  Dep.emit();
});

fs.readFile("./address.txt", "utf8", function (err, res) {
  school.name = res;
  Dep.emit();
});
```

- 上面的代码，如果直接在三个 readFile 后输出 school 只能得到一个空的对象，因为 readFile 的回调函数是异步执行的
- 会先执行 console.log(school)，再执行异步函数
- 因此可以使用订阅发布来实现
- 观察者模式是基于订阅发布的
- 订阅发布这种模式可以使用 promise 代替

## Promise

- Promise 可以解决 1.回调地狱 2.上述多个异步请求在同一时间合并结果 的问题
- Promise 的例子:

```js
let p = new Promise(function (resolve, reject) {
  console.log(111);
});

console.log(222);
// expecting result: 111 222
// 因为Promise中的executor函数是同步执行的
```

- new Promise 时要传递一个 executor 执行器（同步执行的）
- executor 中有两个参数，resolve 代表成功，reject 代表失败
- 每个 Promise 的实例上都有一个 then 方法，then 方法中有两个函数 (成功函数, 失败函数)
- Promise 中有三个状态，为 pending 态，resolved 态，rejected 态
- pending 态可以转换为 resolved 态或 rejected 态

### 原本的回调方式实现异步函数合并结果

```js
const fs = require("fs");
const school = [];
fs.readFile("./name.txt", "utf8", function (err, res) {
  school.push(res);
  fs.readFile("./address.txt", "utf8", function (err, res) {
    school.push(res);
    fs.readFile("./age.txt", "utf8", function (err, res) {
      school.push(res);
      console.log(school); // expecting result: [ '学军', '杭州', '10' ]
    });
  });
});
```

- 这种方式大量嵌套回调函数，不太优雅

### Promise 的链式调用方法

```js
const fs = require("fs");

function read(url, encoding) {
  return new Promise(function (resolve, reject) {
    fs.readFile(url, encoding, function (err, res) {
      if (err) reject(err);
      resolve(res);
    });
  });
}

read("./name.txt", "utf8")
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    console.log(value);
  })
  .catch(function (err) {
    console.log("catch", err);
  });
```

- 每次调用 then 方法后，会返回一个新的 Promise
- Promise 链式调用，解决了回调嵌套问题

### Promise 中的 catch

- 上述代码中如果中间有一环产生了错误，如下

```js
read("./name.txt", "utf8")
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    return read(value + 1, "utf8"); // 在这里制造一个错误
  })
  .then(function (value) {
    console.log(value);
  }).then().then().then(). // 值的穿透
  .catch(function (err) {
    console.log("catch", err);
  });
```

- 错误信息会一直往下传，称为值的穿透
- 错误被 catch 接收

### Promise 中 then 的返回值问题

```js
read("./name.txt", "utf8")
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    return read(value + 1, "utf8");
  })
  .then(function (value) {
    console.log(value);
  })
  .catch(function (err) {
    console.log("catch", err); // 返回的值是普通值
  })
  .then(
    function (value) {
      console.log("then", value); // expecting result: then undefined
    },
    function () {}
  );
```

- 如果 then 返回的是一个 Promise，则会把 Promise 的结果传给下一个 then 的参数
- 如果 then 返回的是一个普通值，则会把值传给下一个 then 的成功的结果
- 如果想要返回值走的是下一个 then 的失败方法，则 return Promise.reject();

```js
read("./name.txt", "utf8")
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    return read(value + 1, "utf8");
  })
  .then(function (value) {
    console.log(value);
  })
  .catch(function (err) {
    console.log("catch", err);
  })
  .then(function (value) {
    console.log("then", value);
    return Promise.reject("失败了"); // 这里返回的是Promise的失败
    // 相当于下面代码
    // return new Promise((resolve,reject) => reject('失败了'));
  })
  .then(null, function (err) {
    console.log(err); // 被下一个then的失败方法接收
  });
```

### throw

```js
read("./name.txt", "utf8")
  .then(function (value) {
    return read(value, "utf8");
  })
  .then(function (value) {
    return read(value + 1, "utf8");
  })
  .then(function (value) {
    console.log(value);
  })
  .catch(function (err) {
    console.log("catch", err);
  })
  .then(function (value) {
    console.log("then", value);
    throw new Error("错误了");
  })
  .then(null, function (err) {
    console.log("throw", err); // expecting result: throw Error: 错误了
  });
```

### Promise.all

// 多个异步并发执行，需要在同一时刻内获取最终结果

```js
Promise.all([1, 2, 3, 4]).then(function (res) {
  console.log(res); // expecting result: throw Error: [1, 2, 3, 4]
});
```

- all 方法会返回一个新的 Promise，新的 Promise 可以跟一个 then
- all 中不仅仅可以放数字，还能放 Promise，上面的 read 函数的返回值就是 Promise，可以把 read 放入

```js
Promise.all([
  read("./name.txt", "utf8"),
  read("./address.txt", "utf8"),
  read("./age.txt", "utf8"),
]).then(function (res) {
  console.log(res); // expecting result: [ '学军', '杭州', '10' ]
});
```

- all 中的所有 read 是并发执行的
- 能够保证结果的顺序和调用时一样
